using System;
using Newtonsoft.Json;

namespace TdLib
{
    /// <summary>
    /// Autogenerated TDLib APIs
    /// </summary>
    public static partial class TdApi
    {
        /// <summary>
        /// Describes a message
        /// </summary>
        public class Message : Object
        {
            /// <summary>
            /// Data type for serialization
            /// </summary>
            [JsonProperty("@type")]
            public override string DataType { get; set; } = "message";

            /// <summary>
            /// Extra data attached to the message
            /// </summary>
            [JsonProperty("@extra")]
            public override string Extra { get; set; }

            /// <summary>
            /// Message identifier, unique for the chat to which the message belongs
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("id")]
            public long Id { get; set; }

            /// <summary>
            /// Identifier of the user who sent the message; 0 if unknown. Currently, it is unknown for channel posts and for channel posts automatically forwarded to discussion group
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sender_user_id")]
            public int SenderUserId { get; set; }

            /// <summary>
            /// Chat identifier
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("chat_id")]
            public long ChatId { get; set; }

            /// <summary>
            /// Information about the sending state of the message; may be null
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sending_state")]
            public MessageSendingState SendingState { get; set; }

            /// <summary>
            /// Information about the scheduling state of the message; may be null
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("scheduling_state")]
            public MessageSchedulingState SchedulingState { get; set; }

            /// <summary>
            /// True, if the message is outgoing
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_outgoing")]
            public bool IsOutgoing { get; set; }

            /// <summary>
            /// True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the client
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_edited")]
            public bool CanBeEdited { get; set; }

            /// <summary>
            /// True, if the message can be forwarded
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_forwarded")]
            public bool CanBeForwarded { get; set; }

            /// <summary>
            /// True, if the message can be deleted only for the current user while other users will continue to see it
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_deleted_only_for_self")]
            public bool CanBeDeletedOnlyForSelf { get; set; }

            /// <summary>
            /// True, if the message can be deleted for all users
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_deleted_for_all_users")]
            public bool CanBeDeletedForAllUsers { get; set; }

            /// <summary>
            /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_channel_post")]
            public bool IsChannelPost { get; set; }

            /// <summary>
            /// True, if the message contains an unread mention for the current user
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("contains_unread_mention")]
            public bool ContainsUnreadMention { get; set; }

            /// <summary>
            /// Point in time (Unix timestamp) when the message was sent
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("date")]
            public int Date { get; set; }

            /// <summary>
            /// Point in time (Unix timestamp) when the message was last edited
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("edit_date")]
            public int EditDate { get; set; }

            /// <summary>
            /// Information about the initial message sender; may be null
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("forward_info")]
            public MessageForwardInfo ForwardInfo { get; set; }

            /// <summary>
            /// If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("reply_to_message_id")]
            public long ReplyToMessageId { get; set; }

            /// <summary>
            /// For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("ttl")]
            public int Ttl { get; set; }

            /// <summary>
            /// Time left before the message expires, in seconds
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("ttl_expires_in")]
            public double? TtlExpiresIn { get; set; }

            /// <summary>
            /// If non-zero, the user identifier of the bot through which this message was sent
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("via_bot_user_id")]
            public int ViaBotUserId { get; set; }

            /// <summary>
            /// For channel posts, optional author signature
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("author_signature")]
            public string AuthorSignature { get; set; }

            /// <summary>
            /// Number of times this message was viewed
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("views")]
            public int Views { get; set; }

            /// <summary>
            /// Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums
            /// </summary>
            [JsonConverter(typeof(Converter.Int64))]
            [JsonProperty("media_album_id")]
            public Int64 MediaAlbumId { get; set; }

            /// <summary>
            /// If non-empty, contains a human-readable description of the reason why access to this message must be restricted
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("restriction_reason")]
            public string RestrictionReason { get; set; }

            /// <summary>
            /// Content of the message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("content")]
            public MessageContent Content { get; set; }

            /// <summary>
            /// Reply markup for the message; may be null
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("reply_markup")]
            public ReplyMarkup ReplyMarkup { get; set; }
        }
    }
}